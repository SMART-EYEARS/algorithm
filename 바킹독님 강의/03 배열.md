배열
======
# 정의와 성질
## 정의   
![image](https://user-images.githubusercontent.com/50267433/130442870-42a015d6-e821-4998-81b3-3023b257d523.png)  
   
**배열 :** 메모리 상에 원소를 연속하게 배치한 자료구조    

## 성질    
1. O(1)에 K번째 원소를 확인/변경 가능 
2. 추가적으로 소모되는 메모리 양(overhead)이 거의 없음   
3. [Cache hit rate](https://ndlessrain.tistory.com/entry/%EC%BA%90%EC%8B%9C%EB%A9%94%EB%AA%A8%EB%A6%AC-%EC%A0%81%EC%A4%91%EB%A5%A0Hit-Rate)가 높음
4. 메모리 상에 연속한 구간을 잡아야 해서 할당에 제약이 걸림   

# 기능과 구현  
조회에 대해서는 O(1)이지만,        
수정/삭제에 대해서는 O(N)이다.      

# 문제 
## 백준 알파벳

## O(N^2) 대신 O(N) 으로 풀어보기   
  
![image](https://user-images.githubusercontent.com/50267433/130455943-c67d5d1b-6c54-4e39-8fce-c46438aab447.png)

위와 같은 문제 예시가 있다.     
보통 같은 경우 한 숫자를 기준으로 다른 숫자 전부를 도는 방식을 채택하기에 `O(N^2)`이 걸린다.     
이 문제를 어떻게 해야 `O(N)`으로 바꿀 수 있을까?      
  
배열을 이용하면 아주 손쉽게 해결할수 있다.      
자신과 더하면 100이 되는 숫자의 배열 카운트가 1인지 확인한다.      
1이 아니라면 자기 자신을 1의 값을 채우고 다음 인덱스로 넘어간다.      
   
![image](https://user-images.githubusercontent.com/50267433/130456272-a0b1d0eb-97cc-4d28-a883-22c5b4a07334.png)
   
이런식으로 진행하다보면 위와 같은 상황을 만나는데 비로소 정답이 도출된다.     
물론, 중간에 정답이 도출되지 않는다면 100이 되는 쌍이 없다는 정답이 도출된다.   

![image](https://user-images.githubusercontent.com/50267433/130456374-34007064-79f5-4679-9f51-a21a214711ca.png)


